# 서비스 워커 생명주기와 캐시 관리

앞에서 서비스 워커의 생명주기를 다루었다.  
우리는 Update on reload 모드를 새로고침될 때마다 서비스 워커에 변경사항이 바로 알 수 있도록 했습니다.  
하지만 이 방법은 서비스 사용자에게 권장할 수 있는 방법은 아닙니다.

서비스 워커의 특성을 처음 접할 때는 혼란스러울 수 있지만 서비스 워커의 생명 주기를 잘 짚고 넘어가면 서비스 워커가 무슨 이유로 이렇게 동작하는지 명확하게 이해할 수 있다.

```js
self.addEventListener("install", function () {
  console.log("install");
});

self.addEventListener("activate", function () {
  console.log("activate");
});

self.addEventListener("fetch", function (event) {
  if (event.request.url.includes("bootstrap.min.css")) {
    console.log("Fetch request for: ", event.request.url);

    event.respondWith(
      new Response(
        ".hotel-slogan {background: green! important;} nav {dispaly: none}",
        { headers: { "Content-Type": "text/css" } }
      )
    );
  }
});
```

서비스 워커는 첫번째 새로고침에서 성공적으로 설치되고 활성화된다. 하지만 fetch이벤트는 없었기 떄문에 스타일 시트는 변함없이 그대로였다. 서비스 워커가 fetch이벤트를 받기 위해 새로고침을 한번더 해야했던 이유는 무엇일까?

이를 이해하려면 서비스 워커의 생명주기를 이해해야한다.

설치중 -> 설치됨 -> 활성화중 -> 활성화됨 -> 중복
설치중 -> 중복

**설치중(Installing)**
navigator.serviceWorker.register를 사용하여 새로운 서비스 워커를 등록할 때, 자바스크립트가 다운로드되고 나면, 서비스 워커는 설치중 상태에 들어갑니다.  
설치가 성공적으로 이뤄지면, 설치됨 상태로 변경됩니다. 설치중 에러가 발생하면 페이지를 새로고침하여 서비스 워커를 다시 등록하거나, 아니면 스크립트는 중복(Redundent)상태의 구렁으로 영원히 빠져버리게 됩니다.

Install 이벤트 콜백 내에서 waitUntil()을 호출하면, 설치중 상태를 연장할 수 있습니다. 인자로 전달된 프로미스가 완료되기 전에는 서비스 워커의 상태가 변경되지 않습니다. 만일 프로미스가 성공적으로 리졸브되면, 서비스 워커는 설치됨 상태로 변경되고, 실패한다면, 전체 설치 과정이 실패하고 서비스 워커는 중복 상태가 될 것입니다.

설치됨 상태로 넘어가기전, 캐싱 함수에서 반환되는 프로미스가 리졸브 될 때까지 기다립니다. 파일중 어느 하나ㅏㄹ도 캐싱되지 않으면 설치가 실패하고, 서비스 워커는 곧장 중복상태로 넘어갑니다.

**설치됨/대기중(Installed/Waiting)**  
서비스워커가 성공적으로 설치되면 설치됨 상태로 넘어가게됩니다. 현재 활성화되어있는 다른 서비스 워커가 앱을 제어하고 있지 않으면 바로, 활성화 중 상태로 전환됩니다. 앱을 제어하고 있는 경우에는 대기중 상태가 유지됩니다.

**활성화중(Activating)**
서비스 워커가 활성화되어 앱을 제어하기 전, activate이벤트가 발생합니다. 설치중 상태와 비슷하게 활성화중 상태 또한 event.waitUntil()을 호출하여 연장할 수 있습니다.

**활성화됨(Activated)**
서비스 워커가 활성화되면, 페이지를 제어하고 fetch이벤트와 같은 동작 이벤트를 받을 준비가됩니다.
서비스 워커는 페이지 로딩이 시작하기 전에만 페이지 제어 권한을 가져올 수 있습니다.  
즉 서비스 워커가 활성화되기 전에 로딩이 시작된 페이지는 서비스 워커가 제어할 수 없습니다.

**중복(Redundant)**
서비스 워커가 등록중, 설치중 실패하거나 새로운 버전으로 교체되면 중복 상태가 됩니다.  
이 상태의 서비스 워커는 앱에 아무런 영향을 미치지 못합니다.

> 서비스 워커나 서비스 워커의 상태는 개별 브라우저나 탭의 영향을 받지 않습니다. 즉, 활성화됨 상태에 들어간 서비스 워커가 이미 존재하면, 사용자가 또 다른 탭을 열어 서비스 워커등록을 요청하는 경우에도 서비스 워커는 같은 상태를 유지합니다. 페이지가 이미 활성화된 서비스 워커 등록을 요청하는 경우, 브라우저는 이를 감지하여 서비스 워커를 다시 설치하지 않습니다. 다시 말해 install 이벤트와 activate 이벤트는 서비스 워커의 생명주기동안 한번만 발생합니다.

사용자가 사이트에 처음 방문하면 앱은 서비스 워커를 등록합니다. 이때 서비스 워커 파일이 다운로드되면서 설치가 시작됩니다. install이벤트가 발생하고 콘솔에 상황을 출력하는 함수가 호출됩니다. 서비스 워커는 설치됨 상태로 들어서고, 그 즉시 활성화중 상태가 됩니다. 다시한번 activate이벤트에 의한 함수 하나가 호출되어 콘솔에 상태 변경을 출력합니다. 마지막으로, 서비스 워커는 활성화됨 상태로 들어갑니다. 서비스 워커는 이제 활성화되어있고, 범주 내의 페이지를 제어할 준비가 되어있습니다.

하지만 안타깝게도 서비스 워커가 설치되는 동안, 페이지는 이미 로딩과 렌더링을 시작했습니다. 즉 서비스 워커가 활성화된다고 하더라도, 이 페이지를 제어할 수 없다는 뜻이죠. 페이지를 다시 한번 새로고침해야 페이지 로딩 전에 서비스 워커가 활성화될 수 있습니다. 이제 서비스 워커가 활성화되고 페이지도 제어하며, fetch이벤트를 수신하고 실행할 수 있습니다.

> 만일 서비스 워커가 페이지 로딩 후에도 페이지를 제어할 수 있다면. 비디오 파일이 너무 느리게 로딩되고 있는 것을 감지하여 같은 비디오 호스팅을 하는 다른 미러 서버의 링크를 제공하는 서비스 워커를 상상해보자. 이 서비스 워커는 비디오 파일에 대한 모든 요청을 가로채어, 요청된 비디오를 반환하거나 미러 사이트 링크를 제공하는 JSON파일을 반환한다. 또한 app.js에 대한 요청을 가로채서 대신 미러 사이트 링크가 포함된 JSON 파일을 올바르게 처리할 수 있는 app-sw.js를 제공한다. 페이지가 로딩되기 전에 서비스 워커가 페이지 제어를 한다면 어떤 일이 일어날지 생각해보세요. 서비스 워커가 페이지 제어를 시작하기 전, 페이지가 수정되지 않은 app.js를 내려받고, 비디오 요청이 들어왔을 때 서비스 워커에서 JSON 파일을 내려받기 시작하면 어떻게 될까요? app.js는 응답을 어떻게 처리해야할지 모르고 전체 페이지 작동이 꺠질 수 있습니다. 서비스 워커 로딩이 시작된 후 페이지를 제어할 수 없도록 제한함으로써, 하나의 페이지는 로딩 시점부터 페이지를 닫을 때까지 하나의 서비스 워커로만 제어되도록 합니다.

브라우저가 현재 등록된 서비스 워커를 항상 실행 상태로 유지하는 것은 아닙니다. 만약 그렇다면, 사이트가 서비스 워커를 많이 등록할 수록 실행되고 있는 서비스 워커 또한 늘어나면서 성능이 급격히 덜어질 것입니다.

서비스 워커의 수명은 서비스 워커가 처리하는 이벤트와직접적으로 연관 되어 있습니다.서비스 워커 범위 내에서 이벤트가 발생한다면, 서비스 워커는 활성화되고 이벤트를 처리한 후 종료됩니다.

다시말해 사용자가 사이트를 방문할 때, 서비스 워커가 시작되고, 페이지에서 이벤트 처리를 완료하는 즉시 종료될 것입니다. 다른 이벤트가 나중에 들어온다면, 서비스 워커는 다시 시작되고 완료되는 즉시 종료될 것입니다.

만약 서비스 워커의 이벤트 핸들링 코드가 비동기적으로 호출되도록 설정되어 있다면? -> 그 예로 push 이벤트 핸들러에 대해 살펴봅시다.서버가 사용자에게 push 메시지를 보낼 때 push이벤트가 트리거 됩니다. (앱이 실행되지 않고 있을 때에도)

```js
self.addEventListener("push", function () {
  fetch("/updates").then(function (response) {
    return self.registration.showNotification(response.text());
  });
});
```

**push이벤트가 발생하면, 서버로부터 업데이트를 가져오기 위해 시도하고, 응답을 받게 되면 업데이트를 사용자에게 알립니다.  
하지만 위 코드는 업데이트를 확인하기 위해 fetch 요청이 비동기적으로 진행되는 동안 이벤트 리스너 코드가 종료됩니다. 이때 이벤트가 끝나면 fetch요청에 대한 응답을 받기 전에 브라우저가 서비스 워커를 종료하게 됩니다.**

브라우저가 서비스 워커 작업이 완료될 때까지 기다리게(waitUntil) 하려면 어떻게 해야할까요? 서비스 워커의 수명은 실행중인 이벤트 리스너 코드와 직접적으로 연관되어 있습니다. waitUntil을 사용하여 필요한 작업이 완료될 때까지 이벤트 리스너 코드 실행을 연장하면 서비스 워커가 종료되는 것을 막을 수 있습니다.

```js
self.addEventListener("push", function (event) {
  event.waitUntil(
    fetch("/updates").then(function (response) {
      return self.registration.showNotification(response.text());
    })
  );
});
```

활성화된 서비스 워커와 함께 페이지가 로드되면, 해당 페이지는 서비스 워커 스크립트에 대한 업데이트가 있는지확인합니다. 서비스 워커가 등록된 이후 파일이 변경되면 새 파일이 등록되고 설치됩니다. 설치가 완료되면 새로운 서비스 워커는 기존 서비스 워커로 바로 교체되지 않는대신 대기중 상태에 남게됩니다.

기존 서비스 워커의 범위에 해당하는 모든 탭과 윈도우 창이 종료되거나, 범위를 벗어난 새로운 페이지로 이동할 때까지, 새로운 서비스 워커는 대기중 상태를 유지하게 됩니다. 활성화된 서비스 워커가 제어하는 페이지가 더이상 열려있지 않을 때에만, 활성화되어 있던 이전의 서비스 워커가 중복 상태가 되고 새 서비스 워커가 활성화됩니다.

같은 서비스 워커로 제어되는 두 페이지가 각각의 탭에서 열려 있다고 가정해 봅시다. 첫번째 탭이 새로고침되면서 새로운 서비스 워커를 내려받아 해당 서비스 워커가 활성화되면 어떨까요? 하나의 서비스 워커를 사용하고 로드했던 두번째 페이지가 갑자기 다른 서비스 워커로 제어되기 시작합니다. 하지만 기존 서비스 워커로 제어되던 예전 페이지가 남아있을 때, 서비스 워커 설치가 끝나고 로딩된 새 페이지는 왜 새 서비스 워커로 제어되지 않는 걸까요?

새 버전의 서비스 워커를 릴리즈하고 이 서비스 워커의 install이벤트가 캐시에서 user-data.json을 지우고 대신 users.json을 추가한다고 가정해봅시다. 그 후 사용자 데이터를 요청하면 기존 파일 대신 새로운 캐시 파일을 사용해 fetch이벤트에 응답합니다.

만약 여러 서비스 워커가 서로 다른 페이지를 제어했다면 예쩐 서비스 워커로 제어된 페이지는 이미 삭제된 구식 user-data.json을 캐시에서 찾을 것이고, 결과적으로 앱이 정상적으로 작동하지 않습니다.

열려있는 모든 탭이 로딩된 순간부터 종료될 때까지 같은 서비스 워커로 제어되도록하면 이러한 문제를 피할 수 있습니다. 언제든 어느 서비스워커가 책임지고 있는지 예측 가능하도록 해야합니다.

## 캐시를 관리해야하는 이유

오프라인 홈페이지의 콘텐츠를 변경하기로 했다고 가정해봅시다. sw-index.html이 업데이트 되었다면, 서비스 워커가 새 버전 파일을 내려받고 CacheStorage에 저장해야 한다는 것을 어떻게 알 수 있을까요?

서비스 워커는 설치 단계에 있는 동안 필요한 파일을 내려받고 캐시에 저장합니다. 이 파일을 다시 내려받고 캐싱하려면 다시 한번 install이벤트가 발생되어야합니다. 서비스워커에 변경사항이 있다면 다음번 사용자가 앱 페이지를 방문할 때 새로운 서비스 워커가 설치됩니다.

캐시명에 버전 넘버를 달고, 파일이 변경될 때마다 버전 숫자를 증가시키면 다음 두 목표를 이룰 수 있습니다.

1. 변경사항이 서비스 워커 파일에 반영되면 (캐시 버전 숫자의 한 자리수를 바꾸는 것과 같은 소소한 변경일지라도) 브라우저는 활성화된 서비스 워커를 새로운 서비스 워커로 바꿔 설치해야 함을 알게 됩니다. 이는 새 파일을 내려받고 캐시에 저장하도록 하는 새 install이벤트를 발생시킵니다.
2. 이 방법은 각 버전의 서비스 워커에 해당하는 별도의 캐시를 생성합니다. 이것이 중요한 이유는 캐시가 이미 업데이트되었더라도, 사용자가 열려있는 모든 페이지를 닫기 전까지는 기존 서비스 워커가 활성화되어 있기 때문입니다. 서비스 워커는 새로운 서비스 워커가 변경한 파일을 포함한 특정 파일이 캐시에 있을 것임을 예상할 수 있습니다. 각각의 서비스워커가 각자의 캐시를 가지고 있게 함으로써 예상치 못한 오류를 방지할 수 있습니다.

서비스 워커와 캐시 버전명을 동일하게 사용하면 작업하기 훨씬 수월해집니다.

> 저장 용량 한도
> 브라우저는 CacheStorage관리하기, 각 사이트 캐시에 공간할당하기, 이전 캐시 항목지우기와 관련해 각각 다르게 작동합니다. 사이트에 할당된 공간의 양은 브라우저, 버전, 기기에 따라 매일 변할 수 있습니다. 또한 사이트의 저장제한외에도 대부분의 브라우저는 전체 캐시에 대한 용량 제한을 두고 있습니다. 캐시가 한도에 도달하면 브라우저는 가장 오래전에 접속했던 사이트의 캐시를 삭제합니다.

caches.delete(cacheName)
첫번째 인수로 캐시명을 받고 캐시를 삭제

caches.keys()
접근 가능한 모든 캐시의 이름을 받아오는 편리한 방법. 캐시명 배열을 리졸브하는 프로미스를 반환.

만약 전체 캐시를 삭제하고자 한다면 다음 코드를 사용할 수 있습니다.

```js
caches.keys().then(function (cacheNames) {
  cacheNames.forEach(function (cacheName) {
    caches.delete(cacheName);
  });
});
```

이 방법을 사용해 캐시를 관리하는 방법에 대해 알아보겠습니다.
현재 활성화되어있는 서비스워커에 대한 캐시하나, 지금 막 설치되어있으나 아직 활성화되지 않은 새로운 서비스 우커에 대한 캐시가 하나 필요합니다. 중복된 서비스 워커에 종속되어있는 캐시는 모두 필요하지 않습니다.

서비스워커의 생명주기 관점으로 이를 나눠보면,

1. 새로운 서비스 워커를 설치할 때마다 새로운 캐시를 생성합니다.
2. 새로운 서비스 워커가 활성화되면, 이전 서비스 워커가 생성해 두었던 모든 다른 캐시는 삭제하는 것이 안전합니다.

```js
self.addEventListener("activate", function (event) {
  console.log("activate");

  event.waitUntil(
    caches.keys().then(function (cacheNames) {
      return Promise.all(
        cacheNames.map(function (cacheName) {
          if (CACHE_NAME !== cacheName && cacheName.startsWith("gih-cache")) {
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});
```

waitUntil을 사용해 activate 이벤트를 연장시킵니다.
기본적으로 서비스 워커는 활성화가 완료되기 전에 오래된 모든 캐시를 삭제할 때까지 기다릴 것(waitUntil)을 요청받습니다. waitUntil에 promise를 전달해 이를 진행할 수 있습니다.

이 프로미스를 생성하는 코드는 caches.keys()를 호출하는 것으로 시작합니다. 이 함수는 앱에서 생성한 모든 캐시의 이름을 담은 배열을 리졸브하는 프로미스를 반환합니다. 이 배열을 갖고, 이름이 가리키는 각각의 캐시를 모두 순회한 후 리졸브되는 프로미스를 생성하고자 합니다.
이를 위해 Promise.all()를 사용해 여러개의 프로미스를 하나의 프로미스로 감쌀 수 있습니다.

Promise.all은 프로미스 배열을 받고, 배열 내 모든 프로미스가 일단 리졸브되면 리졸브되는 한개의 프로미스를 반환합니다. 만약 그 프로미스중 하나라도 리젝된다면, Promise.all()이 생성한 프로미스 또한 리젝될 것입니다. 만약 모두 성공적으로 리졸브되었다면, Promise.all()로 생성된 프로미스도 성공적으로 리졸브 됩니다.

`
