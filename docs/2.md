# 당신의 첫 번째 서비스 워커

개발자는 일반 사용자에 비해 성능 좋은 데스크톱, 노트북, 모바일 기기를 통해 사이트에 접속한다.
또한, 로컬 서버나 가까이에 있는 개발 서버와의 연결도 안정적이다. 그러나 일반 사용자는 전혀 다른 환경에서 웹 앱을 경험한다.

서비스 워커의 브라우저 지원 여부를 테스트하면 구형브라우저 사용자도 앱을 이용할 수 있고 최신 브라우저 사용자에게도 향상된 경험을 제공할 수 있습니다. 이러한 **점진적 향상은** 프로그레시브 웹 앱 구축의 핵심 방법이다.

register 함수를 호출하면 프로미스가 반환된다. 프로미스가 결과값을 반환하면 서비스 워커가 성공적으로 등록된 것입니다.

```js
if ("serviceWorker" in navigator) {
  navigator.serviceWorker
    .register("/sw.js")
    .then(function (registration) {
      console.log(
        "ServiceWorker registration successful with scope: ",
        registration.scope
      );
    })
    .catch(function (err) {
      console.log("ServiceWorker registration failed: ", err);
    });
}
```

then 구문에 정의된 함수가 호출되고 만일 문제가 있을 경우 catch블록에 정의된 함수가 호출됩니다.

```js
self.addEventListener("fetch", function (event) {
  console.log("Fetch request for:", event.request.url);
});
```

**서비스워커 내의 self는 서비스 워커 자체를 참조한다.**

이 리스너는 모든 fetch 이벤트를 수신한다. 이벤트를 수신하면 등록된 함수를 실행한다.  
이벤트를 수신하면 등록된 함수를 실행한다. 이때, 이벤트 객체가 유일한 인수로 전달된다.  
등록된 함수는 request객체 (fetch이벤트의 속성으로 접근 가능)에 접근해 request의 URL을 콘솔에 출력한다.

페이지를 새로고침하면, 페이지에서 발생한 모든 URL요청이 브라우저 콘솔에 기록된다.

### 서비스 워커의 생명주기

서비스 워커 파일을 변경할 때, 브라우저를 새로고침하더라도 변경 내용이 바로 적용되지는 않는다. 기존 서비스 워커가 여전히 활성화(active)상태이기 때문이다. 새로운 서비스 워커는 기존 서비스 워커가 페이지를 제어하고 있는 동안 대기(waiting) 상태로 남는다.

크롬 브라우저에서 service worker 탭에서 update on reload를 활성화하면 서비스 어커를 변경하고 페이지를 새로 고칠 때마다 서비스 워커가 페이지를 즉시 제어한다.
